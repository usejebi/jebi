package io

import (
	"bufio"
	"encoding/base64"
	"fmt"
	"strings"
	"time"
)

// ToK8sSecret converts a map of secrets into a Kubernetes Secret YAML.
func ToK8sSecret(secrets map[string]string, env, name, namespace string) string {
	if namespace == "" {
		namespace = "default"
	}

	header := fmt.Sprintf(`# Generated by jebi v0.1.0
# Project: %s
# Environment: %s
# Date: %s
# Note: Values are base64-encoded; decode with `+"`echo <val> | base64 -d`"+`
---
`, name, env, time.Now().Format(time.RFC3339))

	var sb strings.Builder
	sb.WriteString(header)
	sb.WriteString("apiVersion: v1\n")
	sb.WriteString("kind: Secret\n")
	sb.WriteString(fmt.Sprintf("metadata:\n  name: %s\n  namespace: %s\n", name, namespace))
	sb.WriteString("type: Opaque\n")
	sb.WriteString("data:\n")

	for k, v := range secrets {
		encoded := base64.StdEncoding.EncodeToString([]byte(v))
		sb.WriteString(fmt.Sprintf("  %s: %s\n", k, encoded))
	}
	return sb.String()
}

// FromK8sSecret parses a Kubernetes Secret YAML into a map[string]string.
// It assumes standard `data:` section with base64-encoded values.
func FromK8sSecret(yaml string) (map[string]string, error) {
	result := make(map[string]string)
	scanner := bufio.NewScanner(strings.NewReader(yaml))

	inDataSection := false
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		if strings.HasPrefix(line, "data:") {
			inDataSection = true
			continue
		}

		if inDataSection {
			// stop if indentation resets (end of data block)
			if !strings.HasPrefix(scanner.Text(), "  ") {
				inDataSection = false
				continue
			}

			// Parse "key: value"
			parts := strings.SplitN(strings.TrimSpace(line), ":", 2)
			if len(parts) != 2 {
				continue
			}

			key := strings.TrimSpace(parts[0])
			val := strings.TrimSpace(parts[1])
			decoded, err := base64.StdEncoding.DecodeString(val)
			if err != nil {
				return nil, fmt.Errorf("invalid base64 for key %q: %w", key, err)
			}
			result[key] = string(decoded)
		}
	}

	return result, scanner.Err()
}
